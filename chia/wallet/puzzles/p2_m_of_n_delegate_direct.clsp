; build an M of N multisig puzzle
; coins are locked by N public keys, any M of which can delegate a sub-puzzle


; glossary of parameter names:

;  PUBLIC_KEY_LIST: a list of N public keys

;  M: the M in "M of N"

;  selectors: a list up of 0s and 1s up to size N where exactly M are 1s
;     It's used to select public keys from PUBLIC_KEY_LIST

;  delegated_puzzle: the puzzle signed by the M public keys
;     This puzzle must return a list of conditions

;  solution: the solution to the delegated puzzle


(mod
    (
      M
      PUBLIC_KEY_LIST
      selectors
      delegated_puzzle
      solution
    )

    (include condition_codes.clib)
    (include sha256tree.clib)
    (include utility_functions.clib) ; assert

    ; add_aggsig returns a list of conditions. It includes M AGG_SIG conditions
    ;   corresponding to the given list of public keys (with the given hash)
    ;   plus the conditions that come out of the delegated puzzle.
    ;
    ; hash is the hash of delegated_puzzle.
    ;  Yes it's redundant since we include the delegated_puzzle itself,
    ;  but we don't want to recalculate the hash multiple times as its expensive to do so

    (defun add_aggsig (PUBLIC_KEY_LIST hash delegated_puzzle solution)
        (if PUBLIC_KEY_LIST
            (c (list AGG_SIG_UNSAFE (f PUBLIC_KEY_LIST) hash)
               (add_aggsig (r PUBLIC_KEY_LIST) hash delegated_puzzle solution)
            )
            (a delegated_puzzle solution)
        )
    )

    ; choose_keys takes a list of selectors and the N public keys and
    ; returns a list of the M public keys chosen by the selectors

    (defun choose_keys (selectors PUBLIC_KEY_LIST)
        (if selectors
            (if (f selectors)
                (c (f PUBLIC_KEY_LIST) (choose_keys (r selectors) (r PUBLIC_KEY_LIST)))
                (choose_keys (r selectors) (r PUBLIC_KEY_LIST)))
            ()
        )
    )


    ; count the number of non-0 values in the list of selectors and return it as an integer

    (defun count_selectors (selectors)
        (if selectors
            (+
                (count_selectors (r selectors))
                (if (f selectors) 1 0)
            )
            0
        )
    )

    ; "solve_puzzle" is the main entry point

    (defun-inline solve_puzzle (M PUBLIC_KEY_LIST selectors delegated_puzzle solution)
        ; make sure we have exactly M selectors
        (assert (= M (count_selectors selectors))
            ; return the AGG_SIG conditions plus the conditions from the delegated_puzzle
                (add_aggsig (choose_keys selectors PUBLIC_KEY_LIST)
                            (sha256tree delegated_puzzle)
                            delegated_puzzle
                            solution)
        )
    )

    ; main
    (solve_puzzle
        M PUBLIC_KEY_LIST
        selectors delegated_puzzle solution
    )
)
